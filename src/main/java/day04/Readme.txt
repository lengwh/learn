锁
公平锁  :多个线程按照申请锁的顺序来获取锁，先来后到
非公平锁(默认)：多个线程并不按申请顺序，有可能会造成优先级反转或者饥饿现象，优点：吞吐量比公平锁大
        synchronized是非公平锁
可重入锁(又名递归锁)：同一线程外层函数获得锁之后，内层函数仍然能获取该锁的代码，在同一个线程在外层方法获得锁的时候，
                  在进入内层方法会自动获取锁
                  也就是线程可以进入任何一个它已经拥有锁的同步着的代码块
                  sycn method1(){method2()}  sycn method2(){}
                  作用：防止死锁
                  典型例子：ReenterLock 和 synchronized
自旋锁：是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式尝试去获取锁
       好处：减少线程上下文切换的消耗， 缺点：会消耗CPU (死循环)
独占锁(写锁)：指该锁一次只能被一个线程所持有，对ReenterLock和synchronized 都是独占锁
共享锁(读锁): 指该锁可被多个线程所持有
互斥锁：


synchronized 和 lock区别？
1.原始构成  synchronized 是关键字属于JVM层面 底层用了monitor
           lock 是个对象，api层面
2.使用方法  synchronized 不需要主动去释放
           需要主动释放，可能造成死锁
3.等待释放可中断
4.加锁是否公平
5.绑定多个condition
            synchronized没有
            ReentrantLock 用来实现分组唤醒，精确唤醒，而synchronized随机唤醒


死锁：两个或多个进程因争抢资源而造成等待的现象
多个线程互相持有各自锁，尝试去获取对方的锁
排查  jps -l 查询java进程号   jstack 进程号  查看堆栈信息

